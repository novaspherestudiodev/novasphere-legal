<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>NOVA | PHASE 4: HOLODECK</title>
    
    <!-- FONTS -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@900&family=Rajdhani:wght@500&family=Share+Tech+Mono&display=swap" rel="stylesheet">
    <link href="https://unpkg.com/boxicons@2.1.4/css/boxicons.min.css" rel="stylesheet">

    <style>
        :root {
            --neon: #00f3ff;
            --alert: #ff0055;
            --void: #000;
        }
        
        * { margin: 0; padding: 0; box-sizing: border-box; cursor: none; }
        
        body { 
            background: var(--void); 
            overflow: hidden; 
            font-family: 'Rajdhani', sans-serif;
            color: white;
        }

        /* === 3D CANVAS === */
        #world {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            z-index: 1; outline: none;
        }

        /* === UI OVERLAY (HUD) === */
        #hud {
            position: fixed; inset: 0; z-index: 10;
            pointer-events: none; /* Let clicks pass to 3D world if needed */
        }

        /* SCANLINES */
        .scanlines {
            position: fixed; inset: 0; z-index: 20;
            background: linear-gradient(rgba(0,0,0,0) 50%, rgba(0,0,0,0.25) 50%);
            background-size: 100% 4px;
            pointer-events: none;
        }

        /* CUSTOM CURSOR */
        #cursor {
            position: fixed; top: 0; left: 0; z-index: 9999;
            width: 20px; height: 20px;
            border: 1px solid var(--neon);
            transform: translate(-50%, -50%) rotate(45deg);
            pointer-events: none;
            transition: width 0.2s, height 0.2s;
            mix-blend-mode: difference;
        }
        #cursor::after {
            content: ''; position: absolute; top: 50%; left: 50%;
            width: 4px; height: 4px; background: var(--neon);
            transform: translate(-50%, -50%);
        }

        /* CONTENT */
        .content-layer {
            position: absolute; top: 50%; left: 10%; 
            transform: translateY(-50%);
            pointer-events: auto;
        }

        h1 {
            font-family: 'Orbitron'; font-size: clamp(3rem, 6vw, 6rem);
            line-height: 0.9; text-transform: uppercase;
            text-shadow: 0 0 20px rgba(0, 243, 255, 0.5);
            margin-bottom: 2rem;
        }

        .btn-holo {
            background: rgba(0, 243, 255, 0.05);
            border: 1px solid var(--neon);
            color: var(--neon);
            padding: 15px 40px;
            font-family: 'Share Tech Mono';
            font-size: 1.1rem;
            text-transform: uppercase;
            letter-spacing: 2px;
            transition: 0.3s;
            clip-path: polygon(10px 0, 100% 0, 100% calc(100% - 10px), calc(100% - 10px) 100%, 0 100%, 0 10px);
        }
        .btn-holo:hover {
            background: var(--neon); color: black;
            box-shadow: 0 0 30px var(--neon);
            cursor: none;
        }

        /* LOADING */
        #loader {
            position: fixed; inset: 0; background: #000; z-index: 1000;
            display: flex; align-items: center; justify-content: center;
            font-family: 'Share Tech Mono'; color: var(--neon);
        }
    </style>
</head>
<body>

    <!-- LOADER -->
    <div id="loader">INITIALIZING 3D ENGINE...</div>

    <!-- 3D WORLD -->
    <canvas id="world"></canvas>

    <!-- OVERLAYS -->
    <div class="scanlines"></div>
    <div id="cursor"></div>

    <!-- INTERFACE -->
    <div id="hud">
        <div class="content-layer">
            <div style="font-family: 'Share Tech Mono'; color: var(--alert); margin-bottom: 10px;">// REALTIME_RENDER</div>
            <h1>
                INFINITE<br>
                <span style="color: transparent; -webkit-text-stroke: 2px var(--neon);">HORIZON</span>
            </h1>
            <p style="max-width: 500px; color: #aaa; margin-bottom: 30px; line-height: 1.6;">
                This environment is rendered in real-time using WebGL. 
                It runs directly on your GPU. No video files. pure code.
            </p>
            <button class="btn-holo" onclick="alert('SYSTEM LINK ESTABLISHED')">ENTER SIMULATION</button>
        </div>
    </div>

    <!-- THE ENGINE (THREE.JS) -->
    <!-- We import Three.js as a Module from a CDN -->
    <script type="module">
        import * as THREE from 'https://unpkg.com/three@0.160.0/build/three.module.js';

        // 1. SCENE SETUP
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x000000, 0.002); // The Void Fog

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 5;
        camera.position.y = 2; // Camera height

        const renderer = new THREE.WebGLRenderer({ canvas: document.querySelector('#world'), antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);

        // 2. LIGHTING
        const ambientLight = new THREE.AmbientLight(0x00f3ff, 0.1); // Cyan tint
        scene.add(ambientLight);

        const pointLight = new THREE.PointLight(0xff0055, 2, 50); // Red glow
        pointLight.position.set(0, 5, 5);
        scene.add(pointLight);

        // 3. THE TERRAIN (WIREFRAME GRID)
        // Creating a plane geometry with many segments for the "wave" effect
        const geometry = new THREE.PlaneGeometry(100, 100, 60, 60); 
        
        // Custom Material: Tron-style grid
        const material = new THREE.MeshBasicMaterial({ 
            color: 0x00f3ff, 
            wireframe: true,
            transparent: true,
            opacity: 0.3
        });

        const terrain = new THREE.Mesh(geometry, material);
        terrain.rotation.x = -Math.PI / 2; // Lay flat
        scene.add(terrain);

        // Duplicate terrain to create "infinite" look
        const terrain2 = terrain.clone();
        terrain2.position.z = -100;
        scene.add(terrain2);

        // 4. ANIMATION LOOP
        let speed = 0.1;
        let time = 0;

        // Access the vertices to animate waves
        const positionAttribute = geometry.attributes.position;
        const vertex = new THREE.Vector3();

        // Hide Loader once engine starts
        document.getElementById('loader').style.display = 'none';

        function animate() {
            requestAnimationFrame(animate);
            time += 0.05;

            // Move Terrains forward to simulate flying
            terrain.position.z += speed;
            terrain2.position.z += speed;

            // Loop terrain positions for infinity
            if (terrain.position.z >= 50) terrain.position.z = -150;
            if (terrain2.position.z >= 50) terrain2.position.z = -150;

            // Waving effect (vertex manipulation)
            for (let i = 0; i < positionAttribute.count; i++) {
                vertex.fromBufferAttribute(positionAttribute, i);
                // Create a wave based on X and Y position
                const waveX = Math.sin(vertex.x * 0.5 + time) * 0.5;
                const waveY = Math.cos(vertex.y * 0.5 + time) * 0.5;
                
                // Update Z (which is Up/Down because we rotated the plane)
                // Note: Since we rotated X by -90deg, the Z axis of geometry is effectively world Y
                // But we modify the local Z of the geometry (perpendicular to plane)
                positionAttribute.setZ(i, waveX + waveY);
            }
            positionAttribute.needsUpdate = true; // Tell GPU to update

            // Dynamic Light Movement
            pointLight.position.x = Math.sin(time * 0.5) * 10;

            renderer.render(scene, camera);
        }

        animate();

        // 5. RESIZE HANDLER
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // 6. CURSOR LOGIC
        const cursor = document.getElementById('cursor');
        document.addEventListener('mousemove', (e) => {
            cursor.style.left = e.clientX + 'px';
            cursor.style.top = e.clientY + 'px';
            
            // Move camera slightly with mouse for parallax
            const mouseX = (e.clientX / window.innerWidth) * 2 - 1;
            const mouseY = (e.clientY / window.innerHeight) * 2 - 1;
            
            camera.rotation.y = mouseX * 0.1;
            camera.rotation.x = mouseY * 0.1;
        });

    </script>
</body>
</html>
